#!/usr/bin/env python3
"""
Auto-Refresh Service for Snowflake Cortex JWT Tokens

This script generates JWT tokens for Snowflake authentication and automatically
refreshes them before expiration. It writes a LiteLLM litellm_config.yaml file with
the fresh token and reloads the proxy server.

Usage:
    pm2 start $(which python3) --name token-refresher -- auto_refresh.py
"""

import time
import base64
import hashlib
import os
import subprocess
import sys

try:
    import jwt
    from cryptography.hazmat.primitives import serialization
    from cryptography.hazmat.backends import default_backend
except ImportError:
    print("Missing dependencies. Install with:")
    print("  pip install cryptography pyjwt")
    sys.exit(1)


# =============================================================================
#                           USER CONFIGURATION
# =============================================================================

# Your Snowflake Account Identifier (use HYPHENS, not underscores)
# Example: "SFSENORTHAMERICA-MYORG-AWS-USW2"
# Find this in Snowflake: Admin > Accounts > Locator
ACCOUNT = "REPLACE_WITH_YOUR_ACCOUNT_ID"

# Your Snowflake Username (case-insensitive, will be uppercased)
USER = "REPLACE_WITH_YOUR_USERNAME"

# Path to your RSA private key file
KEY_PATH = os.path.expanduser("~/.ssh/snowflake_key.p8")

# Snowflake role to use (must have Cortex access)
ROLE = "ACCOUNTADMIN"

# =============================================================================
#                           SERVICE CONFIGURATION
# =============================================================================

# Output config file path
CONFIG_FILE = os.path.join(os.path.dirname(os.path.abspath(__file__)), "litellm_config.yaml")

# PM2 process name for the LiteLLM proxy
PM2_PROXY_NAME = "claude-proxy"

# Refresh interval in seconds (50 minutes - tokens expire at 60)
REFRESH_INTERVAL = 50 * 60

# LiteLLM proxy port
PROXY_PORT = 8001

# Master API key for the proxy
MASTER_KEY = "sk-local-dev-1234"


# =============================================================================
#                              IMPLEMENTATION
# =============================================================================

def get_token() -> str:
    """
    Generate a JWT token for Snowflake key-pair authentication.
    
    Returns:
        str: A signed JWT token valid for ~1 hour
    """
    # Load the private key
    with open(KEY_PATH, "rb") as f:
        private_key = serialization.load_pem_private_key(
            f.read(), password=None, backend=default_backend()
        )
    
    # Generate the public key fingerprint
    pub = private_key.public_key()
    pub_der = pub.public_bytes(
        encoding=serialization.Encoding.DER,
        format=serialization.PublicFormat.SubjectPublicKeyInfo
    )
    fingerprint = "SHA256:" + base64.b64encode(
        hashlib.sha256(pub_der).digest()
    ).decode("utf-8")
    
    # Build the JWT payload
    now = time.time()
    payload = {
        "iss": f"{ACCOUNT.upper()}.{USER.upper()}.{fingerprint}",
        "sub": f"{ACCOUNT.upper()}.{USER.upper()}",
        "iat": now,
        "exp": now + 3590,  # Just under 1 hour
    }
    
    return jwt.encode(payload, private_key, algorithm="RS256")


def write_config(token: str) -> None:
    """
    Write the LiteLLM litellm_config.yaml with the fresh token.
    
    Args:
        token: The JWT token to include in the config
    """
    api_base = f"https://{ACCOUNT}.snowflakecomputing.com/api/v2/cortex/v1"
    
    content = f"""# Auto-generated by auto_refresh.py - DO NOT EDIT MANUALLY
# Last updated: {time.strftime('%Y-%m-%d %H:%M:%S')}

model_list:
  - model_name: claude-sonnet-4-5-20250929
    litellm_params:
      model: openai/claude-sonnet-4-5
      api_base: "{api_base}"
      api_key: "{token}"
      input_map:
        max_tokens: "max_completion_tokens"
      extra_headers:
        X-Snowflake-User: "{USER.upper()}"
        X-Snowflake-Role: "{ROLE}"

  - model_name: claude-haiku-4-5-20251001
    litellm_params:
      model: openai/claude-haiku-4-5
      api_base: "{api_base}"
      api_key: "{token}"
      input_map:
        max_tokens: "max_completion_tokens"
      extra_headers:
        X-Snowflake-User: "{USER.upper()}"
        X-Snowflake-Role: "{ROLE}"

litellm_settings:
  drop_params: true
  # Uncomment for debug logging:
  # set_verbose: true

general_settings:
  master_key: {MASTER_KEY}
"""
    
    with open(CONFIG_FILE, "w") as f:
        f.write(content)
    
    print(f"[{time.strftime('%H:%M:%S')}] ✓ Config written to {CONFIG_FILE}")


def reload_proxy() -> bool:
    """
    Reload the LiteLLM proxy via PM2.
    
    Returns:
        bool: True if reload succeeded, False otherwise
    """
    result = subprocess.run(
        ["pm2", "reload", PM2_PROXY_NAME],
        capture_output=True,
        text=True
    )
    
    if result.returncode == 0:
        print(f"[{time.strftime('%H:%M:%S')}] ✓ Proxy reloaded")
        return True
    else:
        print(f"[{time.strftime('%H:%M:%S')}] ⚠ Proxy not running (will use config on start)")
        return False


def validate_config() -> bool:
    """
    Validate the configuration before starting.
    
    Returns:
        bool: True if config is valid, False otherwise
    """
    errors = []
    
    if ACCOUNT == "REPLACE_WITH_YOUR_ACCOUNT_ID":
        errors.append("ACCOUNT is not configured")
    
    if USER == "REPLACE_WITH_YOUR_USERNAME":
        errors.append("USER is not configured")
    
    if not os.path.exists(KEY_PATH):
        errors.append(f"Private key not found at {KEY_PATH}")
    
    if errors:
        print("Configuration errors:")
        for err in errors:
            print(f"  ✗ {err}")
        print("\nEdit auto_refresh.py and set your Snowflake credentials.")
        return False
    
    return True


def main():
    """Main service loop."""
    print("=" * 50)
    print("  Snowflake Cortex Token Auto-Refresh Service")
    print("=" * 50)
    print(f"  Account:  {ACCOUNT}")
    print(f"  User:     {USER}")
    print(f"  Key:      {KEY_PATH}")
    print(f"  Interval: {REFRESH_INTERVAL // 60} minutes")
    print("=" * 50)
    print()
    
    if not validate_config():
        sys.exit(1)
    
    while True:
        try:
            # Generate new token
            token = get_token()
            print(f"[{time.strftime('%H:%M:%S')}] ✓ Token generated")
            
            # Write config
            write_config(token)
            
            # Reload proxy
            reload_proxy()
            
            # Calculate next refresh time
            next_refresh = time.strftime(
                '%H:%M:%S',
                time.localtime(time.time() + REFRESH_INTERVAL)
            )
            print(f"[{time.strftime('%H:%M:%S')}] → Next refresh at {next_refresh}")
            print()
            
        except FileNotFoundError as e:
            print(f"[{time.strftime('%H:%M:%S')}] ✗ File not found: {e}")
        except Exception as e:
            print(f"[{time.strftime('%H:%M:%S')}] ✗ Error: {e}")
        
        time.sleep(REFRESH_INTERVAL)


if __name__ == "__main__":
    main()
